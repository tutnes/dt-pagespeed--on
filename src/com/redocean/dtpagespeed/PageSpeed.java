
 /**
  * This template file was generated by Dynatrace client.
  * The Dynatrace community portal can be found here: http://community.dynatrace.com/
  * For information how to publish a plugin please visit https://community.dynatrace.com/community/display/DL/How+to+add+a+new+plugin/
  **/ 

package com.redocean.dtpagespeed;

import com.dynatrace.diagnostics.pdk.*;

import java.util.Collection;
import java.util.logging.Logger;

import com.google.api.client.http.GenericUrl;
import com.google.api.client.http.HttpRequest;
import com.google.api.client.http.HttpRequestFactory;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.services.pagespeedonline.Pagespeedonline;
import com.google.api.client.googleapis.javanet.*;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.pagespeedonline.PagespeedonlineRequest;
import com.google.api.services.pagespeedonline.model.PagespeedApiFormatStringV4;
import com.google.api.services.pagespeedonline.model.PagespeedApiPagespeedResponseV4;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

 public class PageSpeed implements Monitor {
	private static final String PARAM_PROTOCOL = "protocol";
	private static final String PARAM_PATH = "path";
	private static final String PARAM_PORT = "port";
	private static final String PARAM_AUTHENTICATION = "authentication";
	private static final String PARAM_FILTER_THIRD_PARTY = "filter_third_party_resources";
	private static final String PARAM_RULE = "rule";
	private static final String PARAM_STRATEGY = "strategy";
	private static final Logger log = Logger.getLogger(PageSpeed.class.getName());


	private String protocol = "https";
	private String path = null;
	private long port = 443;
	private String authentication  = null;
	private boolean filter_third_party_resources = false;
	private String rule = null;
	private String strategy = null;
	private String hostname = null;
	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this
	 * scheduled Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then  will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 *
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		log.finer("setup method: entering");
		// Protocol
		protocol = env.getConfigString(PARAM_PROTOCOL);
		log.finer("Protocol number is : "  + protocol);
		// Path
		path = env.getConfigString(PARAM_PATH);
		log.finer("Path number is : "  + port);
		// Port number
		port = env.getConfigLong(PARAM_PORT);
		log.finer("Port number is : "  + port);
		// Host
		hostname = env.getHost().getAddress();
		log.finer("hostname is : " + hostname);
		// Authentication
		authentication = env.getConfigString(PARAM_AUTHENTICATION);
		log.finer("Authentication API Key is : "  + authentication);
		// Filter third party resources
		filter_third_party_resources = env.getConfigBoolean(PARAM_FILTER_THIRD_PARTY);
		log.finer("Filter third party resources is : "  + filter_third_party_resources);
		// Rule
		rule = env.getConfigString(PARAM_RULE);
		log.finer("Rule is set to : "  + rule);
		// Strategy
		strategy = env.getConfigString(PARAM_STRATEGY);
		log.finer("Strategy is set to : "  + strategy);

		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	 *
	 * <p>
	 * This method is called at the scheduled intervals. If the Plugin execution
	 * takes longer than the schedule interval, subsequent calls to
	 * {@link #execute(MonitorEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 *
	 * @param env
	 *            a <tt>MonitorEnvironment</tt> object that contains the
	 *            Plugin configuration and subscribed measures. These
	*            <tt>MonitorMeasure</tt>s can be used to store measurements.
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
        String urlToCheck = protocol + "://" + hostname;

	    NetHttpTransport httpTransport = GoogleNetHttpTransport.newTrustedTransport();
        HttpRequestFactory requestFactory = new NetHttpTransport().createRequestFactory();
        GsonFactory factory = new GsonFactory();
        Pagespeedonline pso = new Pagespeedonline.Builder(httpTransport, factory,null )
                .setApplicationName(urlToCheck)
                .build();

        Pagespeedonline.Pagespeedapi.Runpagespeed psapi = pso.pagespeedapi().runpagespeed(urlToCheck)
                .setStrategy(strategy)
                .setFilterThirdPartyResources(filter_third_party_resources)
                .setKey(authentication);

        PagespeedApiPagespeedResponseV4 response = psapi.execute();

        //Collection<MonitorMeasure> monitorMeasures = env.getMonitorMeasures("PageStats", "numberResources");
        Collection<MonitorMeasure> monitorMeasures = env.getMonitorMeasures();
		for (MonitorMeasure m : monitorMeasures) {

			//this will book to the monitor measure
            switch(m.getMeasureName()) {
                case "numberResources":
                    m.setValue(response.getPageStats().getNumberResources());
                    break;
                case "cssResponseBytes":
                    m.setValue(response.getPageStats().getCssResponseBytes());
                    break;
                case "flashResponseBytes":
                    m.setValue(response.getPageStats().getFlashResponseBytes());
                    break;
                case "htmlResponseBytes":
                    m.setValue(response.getPageStats().getHtmlResponseBytes());
                    break;
                case "imageResponseBytes":
                    m.setValue(response.getPageStats().getImageResponseBytes());
                    break;
                case "javascriptResponseBytes":
                    m.setValue(response.getPageStats().getJavascriptResponseBytes());
                    break;
                case "numRenderBlockingRoundTrips":
                    m.setValue(response.getPageStats().getNumRenderBlockingRoundTrips());
                    break;
                case "numTotalRoundTrips":
                    m.setValue(response.getPageStats().getNumTotalRoundTrips());
                    break;
                case "numberCssResources":
                    m.setValue(response.getPageStats().getNumberCssResources());
                    break;
                case "numberHosts":
                    m.setValue(response.getPageStats().getNumberHosts());
                    break;
                case "numberJsResources":
                    m.setValue(response.getPageStats().getNumberJsResources());
                    break;
                case "numberRobotedResources":
                    m.setValue(response.getPageStats().getNumberRobotedResources());
                    break;
                case "numberStaticResources":
                    m.setValue(response.getPageStats().getNumberStaticResources());
                    break;
                case "numberTransientFetchFailureResources":
                    m.setValue(response.getPageStats().getNumberTransientFetchFailureResources());
                    break;
                case "otherResponseBytes":
                    m.setValue(response.getPageStats().getOtherResponseBytes());
                    break;
                case "overTheWireResponseBytes":
                    m.setValue(response.getPageStats().getOverTheWireResponseBytes());
                    break;
                case "responseCode":
                    m.setValue(response.getResponseCode());
                    break;
                case "textResponseBytes":
                    m.setValue(response.getPageStats().getTextResponseBytes());
                    break;
                case "totalRequestBytes":
                    m.setValue(response.getPageStats().getTotalRequestBytes());
                    break;
                default:
                    m.setValue(0);
            }






		}

		return new Status(Status.StatusCode.Success);
	}


	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 *
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and
	 * <tt>teardown</tt> are called on different threads, but they are called
	 * sequentially. This means that the execution of these methods does not
	 * overlap, they are executed one after the other.
	 *
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt>
	 * ends -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout,
	 * <tt>execute</tt> stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is
	 * removed -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 *
	 *
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 *
	 * @see Monitor#setup(MonitorEnvironment)
	 */	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		// TODO
	}
}
